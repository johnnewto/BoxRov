#AUTOGENERATED! DO NOT EDIT! File to edit: dev/00_trajectory.ipynb (unless otherwise specified).

__all__ = ['show_img', 'sliceImage', 'rotate', 'get_image_patch', 'Trajectory', 'mark_key_points']

#Cell
# export
import matplotlib.pyplot as plt
import cv2
import PIL
import numpy as np

#Cell
def show_img(im, figsize=None, ax=None, alpha=None):
    ' Show a numpy image '
    if not ax: fig, ax = plt.subplots(figsize=figsize)
    ax.imshow(im, alpha=alpha)
    ax.set_axis_off()
    return ax

#Cell
def sliceImage(img, size, pos):
    "Take a small rectangular slice of a larger image `img`"

    sz0 = size[0] // 2
    sz1 = size[1] // 2

    pos[0] = min(pos[0], img.shape[0] - sz0)
    pos[0] = max(pos[0], 0 + sz0)
    pos[1] = min(pos[1], img.shape[1] - sz1)
    pos[1] = max(pos[1], 0 + sz1)

    b0 = pos[0] - sz0
    e0 = pos[0] + sz0
    b1 = pos[1] - sz1
    e1 = pos[1] + sz1

    # sl = img[b0:e0, b1:e1, :]
    sl = img[b0:e0, b1:e1]
    return sl, pos

#Cell
def rotate(image, angle, center=None, scale=1.0):
    "Rotate an image, about center and optionally scale"
    # grab the dimensions of the image
    (h, w) = image.shape[:2]

    # if the center is None, initialize it as the center of
    # the image
    if center is None:
        center = (w // 2, h // 2)

    # perform the rotation
    M = cv2.getRotationMatrix2D(center, angle, scale)
    rotated = cv2.warpAffine(image, M, (w, h))

    # return the rotated image
    return rotated

#Cell

def get_image_patch(img, pos, size=[400, 600], rot=0, scale=1.0):
    "get smaller image patch from `img` "
    exp_size = 200
    img0, cntr = sliceImage(img, [i+exp_size for i in size], pos[:2])
    rotated = rotate(img0, rot, scale=scale)
    img1, cntr0 = sliceImage(rotated, size, [(i+exp_size) // 2 for i in size])
    return img1, cntr

#Cell

class Trajectory:
    "Creates a random walk trajectory of `length` steps based on the `img`"
    def __init__(self, img, length, xyscale=1, zscale=0.1, zcycles=3, acycles=3, deg=5, startpos=[1000,1000]):
        # global START_POS
        self.img = img
        self.startpos = startpos
        # START_POS = np.array(startpos)
        theta = 2 * np.pi * (np.random.rand(length) - 0.5) * 0.4
        theta = np.cumsum(theta, axis=0)
        z = np.sin(np.linspace(0, zcycles * 2 * np.pi, num=length)) * zscale + 1
        angles = (np.sin(np.linspace(0, acycles * 2 * np.pi, num=length)) * 0.5 + 0.5) * deg
        xy = np.column_stack((np.cos(theta), np.sin(theta)))
        xy[0,0], xy[0,1] = 0, 0  # start at zero
        xy = ((np.cumsum(xy, axis=0)) * xyscale)
        self.xyza = np.column_stack((xy, z, angles))
        self.i = 0
        self.length = length

    def __next__(self):
        if self.i < self.length:
            dy = int(self.xyza[self.i, 0] + self.startpos[0])
            dx = int(self.xyza[self.i, 1] + self.startpos[1])
            da = self.xyza[self.i, 3]
            self.i += 1
        else:
            raise StopIteration()

        cur_img, move_actual = get_image_patch(self.img, [dy, dx], rot=da)

        move_true = move_actual[0], move_actual[1], da

        return [cur_img, move_true]

        # return return_value
    def __iter__(self):
        return self


#Cell
def mark_key_points(cur_img, key_pts):
    key_pts = np.int0(key_pts)
    img_marked = np.copy(cur_img)
    for i in key_pts:
        x, y = i.ravel()
        cv2.circle(img_marked, (x, y), 3, 255, -1)
    return img_marked